<%

additional_paths = Enum.map_join(@app_options[:additional_paths], ":", &"\\(resourcePath)/#{&1}")

%>import Cocoa

class AppDelegate: NSObject, NSApplicationDelegate {
    var isRunning = false
    var bridge : Bridge?
    var statusItem: NSStatusItem?

    func applicationDidFinishLaunching(_ aNotification: Notification) {
        if !isRunning {
            isRunning = true
            statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)
            statusItem?.button?.title = "Livebook"
            statusItem?.button?.target = self
            statusItem?.button?.action = #selector(onClick(_:))

            do {
                bridge = try Bridge()
            } catch {
                print("Failed initializing beam")
                exit(1)
            }
        }
    }

    @objc func onClick(_ sender: AnyObject) {
        print("click!")
        bridge?.sendToProcess(name: ":Elixir.Livebook.NativeBridge", payload: "\":open_url\"")
    }

    func application(_ app: NSApplication, open urls: [URL]) {
        for url in urls {
            var input : String

            if url.isFileURL {
                input = "open_file:\(url.path)"
            } else {
                input = "open_url:\(url)"
            }

            if isRunning {
                rpc(input)
            }
        }
    }
}

func rpc(_ event: String) {
//    if task.terminationStatus != 0 {
//        runAlert(messageText: "Something went wrong")
//    }
}

func runAlert(messageText: String) {
    DispatchQueue.main.sync {
        let alert = NSAlert()
        alert.alertStyle = .critical
        alert.messageText = messageText
        alert.informativeText = "Logs available at: \(logPath)"
        alert.runModal()
    }
}

func log(_ line: String) {
    logFile.write("[\(appName)Launcher] \(line)\n".data(using: .utf8)!)
}
